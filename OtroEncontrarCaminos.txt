    val cambiadoDer: Boolean = false
    val cambiadoIzq: Boolean = false
    val cambiadoAbajo: Boolean = false
    val cambiadoArriba: Boolean = false

    if (size < 0)
    {
      tablero

    }
    else
    {
      println(getElem(pos, tablero), " == ", color)
      if (getElem(pos, tablero) == color)//&& pos != pos_encontrar)
      {
        println("Entra", pos)
        val nuevo:List[Int]  = insertarElementoPosicion(-1, pos, tablero)

        val derecha: List[Int] = nuevo
        val izquierda: List[Int] = nuevo
        val abajo:List[Int] = nuevo
        val arriba:List[Int] = nuevo

        val fila_siguiente: Int = ((pos + M) / M)
        val fila_anterior: Int = ((pos - M) / M)

        val col_siguiente: Int = (pos + 1) % M
        val col_anterior: Int = (pos - 1)  % M
        println("Pos= ", pos, "Col sig= ", col_siguiente, " Col anterior= ", col_anterior)
        if (pos + 1 < size && col_siguiente < M && col_siguiente > 0)
        {
          val cambiadoDer: Boolean = true
          println("Derecha ", pos)
        //  val derecha:List[Int] = encontrarCamino(nuevo, pos_encontrar, pos + 1, N, M, size - 1, true, color) //Derecha
          unirTableros(0, tablero, encontrarCamino(nuevo, pos_encontrar, pos + 1, N, M, size - 1, true, color))
        }

        if (pos - 1 > 0 && col_anterior >= 0 && col_anterior < M - 1)
        {
          println("Izquierda")
          val cambiadoIzq: Boolean = true
         // val izquierda:List[Int] = encontrarCamino(nuevo, pos_encontrar, pos - 1, N, M, size - 1, true, color) //Izquierda
          unirTableros(0, tablero, encontrarCamino(nuevo, pos_encontrar, pos - 1, N, M, size - 1, true, color))
          //   return izquierda
        }

        if (pos + M < size && fila_siguiente < N)
        {
          println("Abajo")
          val cambiadoAbajo: Boolean = true
       //   val abajo:List[Int] = encontrarCamino(nuevo, pos_encontrar, pos + M, N, M, size - 1, true, color) //Abajo
          unirTableros(0, tablero, encontrarCamino(nuevo, pos_encontrar, pos + M, N, M, size - 1, true, color))
        }

        if (pos - M > 0 && fila_anterior > 0)
        {
          println("Arriba")
          val cambiadoArriba: Boolean = true
        //  val arriba:List[Int] = encontrarCamino(nuevo, pos_encontrar, pos - M, N, M, size - 1, true, color) //Arriba
          unirTableros(0, tablero, encontrarCamino(nuevo, pos_encontrar, pos - M, N, M, size - 1, true, color))
        }
        println("Tablero Unido en pos ", pos, ": ", tablero)
        tablero
       // if(cambiadoDer) derecha
       // else if(cambiadoIzq) izquierda
       // else if(cambiadoAbajo) abajo
       // else if(cambiadoArriba) arriba
       // else nuevo
     //   println("Derecha ", derecha)
       // println("Izquierda ", izquierda)
        //println("Arriba ", arriba)
        //println("Abajo ", abajo)
       // val unido:List[Int] = unirCaminos(0,tablero, derecha, izquierda, arriba, abajo)


        /*else
        {
          //nuevo = encontrarCamino(tablero, pos_encontrar, pos + 1, N, M, size - 1, true, color)
          nuevo
        }*/

      }
      else
      {
        if (pos == pos_encontrar)
        {
          val nuevo: List[Int] = insertarElementoPosicion(-1, pos, tablero)
          unirTableros(0, tablero, encontrarCamino(nuevo, pos_encontrar, pos, N, M, size - 1, true, color))
        }
        else
        {
          encontrarCamino(tablero, pos_encontrar, pos + 1, N, M, size - 1, true, color)
        }
      }
    }
  }